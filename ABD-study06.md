---
title: ABD-Study06
date: 2023-11-5 11:11:36
tags:
- ABD
categories:
- ABD-USTC
---

# Index Structures

本章主要介绍索引, 分为以下章节:

- 顺序文件上的索引
- 辅助索引
- 一维索引: B+树, Hash Table
- 多维索引: R-tree, 网格文件, 分段Hash

## 顺序文件的索引

记录按照查找键排序

### 密集索引

每个记录都有一个索引项, 索引项按照查找键排序.

![图一](/figures/06-01.png)

为什么要用密集索引?

- 记录通常比索引项要大
- 索引可以常驻内存
- 有查找键值为K的记录是否存在, 不需要访问磁盘块数据

缺点: **索引占用太多空间** -->用稀疏索引来进行优化

### 稀疏索引

为了降低空间占用, 我们使用稀疏索引

仅部分记录有索引项, 一般情况下为**每个数据块的第一个记录建立索引**, 即不是给所有的记录都建立索引, 而是为每个块建立一个索引, 查找的时候可以先找到对应的数据块, 再在块中进行查找对应的记录.

![图二](/figures/06-02.png)

对无序的情况不太适用

优点:

- 节省了索引空间
- 对同样的记录, 稀疏索引可以使用更少的索引项

缺点:

- 对应"是否存在键值为K的记录", 需要查找磁盘块数据

### 多级索引

索引上再建索引, 如二级索引, 三级索引等

![图三](/figures/06-03.png)

优点:

- 一级索引可能很大而不能常驻内存
- 二级索引更小, 可以常驻内存
- 减少磁盘I/O次数

**二级索引即可用稀疏索引**

一般不考虑三级以上索引, 因为维护多级索引结构比较困难, 且有更好的索引结构---B+树

## 辅助索引

有助于查询键值

主索引:

- 顺序文件的索引
- 记录按索引属性值**有序**
- 根据索引值可以确定记录的位置

辅助索引:

- 数据文件**不需要按查找键有序**
- 根据索引值不能确定记录在文件中的顺序

### 辅助索引的概念

辅助索引只能是密集索引

![图四](/figures/06-04.png)

### 辅助索引中的间接桶

对于重复键值, 密集索引会浪费空间, 所以使用间接桶(介于辅助索引和数据文件之间)

![图五](/figures/06-05.png)

从上图来看, 间接桶是将键值10对应的记录都集中在一个区域里, 这样方便查找

### 倒排索引

应用于文档检索

不同之处:

- 记录----文档
- 记录查找----文档检索
- 查找键-----文档中的词

具体思路: 给每个检索词建立间接桶, 而桶的指针指向检索词出现的文档

![图六](/figures/06-06.png)

## B+树

- 一种树形的多级索引结构
- 树的层数与数据大小相关, 通常为3层
- 所有结点格式相同: 即有n个值, n+1个指针
- 所有叶节点位于同一层

![图七](/figures/06-07.png)

![图七](/figures/06-08.png)

### 查找

从根结点开始, 沿指针向下, 直到叶结点, 然后在叶结点中顺序查找

### 插入

首先查找插入叶结点, 若有空闲位置则插入, 若没有空间 则分裂叶结点, 而分裂叶结点的操作比较复杂

- 叶结点的分裂可视作是父结点中插入一个子结点
- 递归向上分裂
- 分裂过程需要对父结点中的键加以调整
- **例外**: 若根结点分裂, 则需要创建一个新的根结点

例如: 

![图九](/figures/06-09.png)

![图十](/figures/06-10.png)

### 删除

首先查找要删除的键值, 删除; 若结点的键值填充低于规定值, 则进行调整:

- 若相邻的叶结点中键填充高于规定值，则将其中一个键值移到该结点中
- 否则，合并该结点与相邻结点(合并可视作在父结点中删除一个子结点)
- 递归向上删除

若删除的是叶节点中的最小键值, 则需要对父结点的键值加以调整

![图十一](/figures/06-11.png)

### 效率

访问索引的I/O代价= 树高或0(常驻内存), 而一般树高不超过3, 所以索引I/O代价不超过3

通常情况下, 根结点常驻内存, 所以索引代价I/O不超过2

设块大小8KB，键2B（smallint），指针2B ，则一个块可放2048个索引项

## 散列表

散列函数对应桶(buckets), h: 查找键 -> [0, 1, ...]

给定一个查找键K, 对应的记录必定位于h(K)中, 而若一个桶中仅有一块, 则I/O次数为1; 否则由参数B来决定, 平均 = 总块数/B

![图十二](/figures/06-12.png)

### 查找

对于给定的散列键值k, 计算h(k); 根据h(k)定位桶; 查找桶中的块

### 散列表插入

计算插入记录的h(K), 定位桶; 若桶中有空间则插入, 否则创建一个溢出块并将记录置于溢出块中

![图十三](/figures/06-13.png)

### 删除

根据给定键值K计算h(K)，定位桶和记录, 但如何回收溢出块？

### 空间利用率

实际键值数 / 所有桶可放置的键值数 

- <50％：空间浪费
-  >80％：溢出问题
-  50％到80％之间（GOOD！）

### 文件增长

数据文件的增长是桶的溢出块增多, 增加了I/O

解决办法: **动态散列表**

1. 可扩展散列表: 成倍地增加桶数目
2. 线性散列表: 线性增加

### 可扩展散列表

可扩展散列表的每个桶中存储的关键字数量可以根据需要动态地调整。

散列函数h(k)是一个b(足够大)位二进制序列 ，前i位表示桶的数目。i的值随数据文件的增长而增大

b位二进制序列， h(k) 前i位用于区分桶; 前i位构成一个桶数组

![图十四](/figures/06-14.png)

优点: 大部分情况下不存在着溢出块，因此当查找记录时，只需查找一个存储块。

缺点: 桶增长速度快，可能会导致内存放不下整个桶数组，影响其他保存在主存中的数据，波动较大。

### 线性散列表

h(k)仍是二进制位序列，但使用右边(低)i位区分桶

- 桶数＝n，h(k)的右i位＝m
- 若m < n, 则记录位于第m个桶
- 若n ≤ m < 2的i次方, 则记录位于第$m-2^{i-1}$个桶

n的选择: 总是使n与当前记录总数r保持某个固定比例: 意味着仅有当桶的填充度达到超过某个比例后桶数才开始增长

![](/figures/06-15.png)

![](/figures/06-16.png)

![](/figures/06-17.png)

![](/figures/06-18.png)

1. 空间效率优于可扩展散列表
2. 查找性能劣于可扩展散列表
3. 综合性能较好

## 多维数据及应用

同时在数据的多个维上进行匹配, 传统的索引只能索引一维，不适于多维数据处理