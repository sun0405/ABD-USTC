---
title: ABD-Study04
date: 2023-10-22 21:11:36
tags:
- ABD
categories:
- ABD-USTC


---

# Data Representation

- 数据项的表示
- 记录的表示
- 记录在块中的组织
- 记录的修改
- 块在文件中的组织

数据元素的表示层次:  

数据项(属性值的物理组织) -> 记录(元组的物理组织) -> 块(记录的物理存放) -> 文件(文件由磁盘块构成)

偏移量: 表示文件中某个位置相对于文件开头的偏移, 当要对文件进行操作时, 通过偏移量来确定操作的位置.

## 数据项的表示

数据项:

1. 字节序列
2. 表示关系数据库中元组的属性值

### 数据项表示的内容

表示什么: 一些数据

用什么表示: Bytes

### 数据项表示方法: SQL数据类型

与一些编程语言类似: Integer, real, float等等

### 两种不同的数据项表示

- 定长数据项
- 变长数据项: 带长度(常用), Null Terminated

### 数据项表示总结

![图一](/figures/04-01.png)

## 记录

记录是数据项[字段, fields]的集合

### 记录的类型

固定格式/可变格式, 定长/变长

### 固定格式定长记录

所有的记录都具有相同的逻辑结构(模式)

记录的模式:

- fields
- Name of each field
- Type of each field
- Order in record
- Offset of each field in the record

![图二](/figures/04-02.png)

![图三](/figures/04-03.png)

### 记录首部

在记录首部(Head)的描述记录的信息, 如:

- 记录类型
- 记录长度
- 时间戳
- 其他信息

![图四](/figures/04-04.png)

### 可变格式信息

对于可变格式, 每个记录的格式不同, 记录的格式是存储在记录中.

记录以"KEY+VALUE"的方式表示, KEY与VALUE都以字节流的形式存储, 如

```c
typedef struct {
	void *data; //字节流指针
    int size; //字节流长度
} DBT; //存储
```

- 数据类型没有限制
- 应用与数据库之间不需转换数据格式
- 不提供KEY和VALUE的内容和结构信息
- 应用必须知道所用的VALUE的含义

优点:

1. 灵活的记录格式, 适合松散记录
2. 适合处理重复字段
3. 适合记录格式演变

缺点: 标记存储方式的空间代价高, KY方式难以支持复杂查询, 应用负担重且事务处理等实现困难

![图五](/figures/04-05.png)

![图六](/figures/04-06.png)

## 记录在块中的组织

有预先假设: 块的大小固定, 记录组织成单个文件

定长记录的两种块内组织:

- 记录地址rid通常使用<块号, 槽号>表示

![图七](/figures/04-07.png)

变长记录在块内的组织:

![图八](/figures/04-08.png)

其他问题:

- 记录在块中的分隔 (separating records) 
- 记录跨块 vs.记录不跨块 (spanned vs. unspanned) 
- 不同类型的记录聚簇 (mixed record types – clustering) 
- 按序组织 (sequencing) 
- 记录的分裂 (split records) 
- 记录地址 (record address) 
- 记录的修改

### 记录在块内的分隔

定长记录: 不需要分隔

使用特殊标记, 通过块内偏移量

### 跨块/不跨块

**Unspanned**: 记录必须在一个块中存储, 实现简单, 但是空间浪费

**Spanned**: 记录可跨块存储, 有效利用空间, 但实现更复杂

如果记录的大小 > 块的大小, 则必须使用跨块记录

### 不同类型的记录聚簇

是一种多关系上的聚簇

一个块中存储不同类型的记录, 优点是可以使经常一起访问的记录存储在同一块或连续块中.

### 在块中按序存储记录

是一种单关系上的聚簇

将记录按某个字段顺序排列在块中, 优点是可以加快按排序字段查询记录时的效率, 并有利于归并联接

有物理连续和指针连续两种

### 记录的分裂

适合变长记录的混合格式表示:

- 定长部分存储于某个块中
- 变长部分存储于另一个块中
- 与spanned存储类似

## 记录的修改

分为插入和删除

### 插入

记录无序: 

- 插入到任意块的空闲空间中
- 或申请一个新块(当所有块都已满时)
- 记录变长时, 可使用偏移量表

记录有序:

- 找到记录应该放置的块
- 如果有空间, 放入并调节记录顺序即可, 否则有两种方法

![图九](/figures/04-09.png)

### 删除

删除时有以下特点:

- 立即回收空间
- 删除记录时处理溢出块

## 块在文件中的组织

**堆文件**:

- 最基本, 最简单的文件结构
- 记录不以任何顺序排序
- 记录可能存放在物理不邻接的块上

特点: 插入容易, 但查找和删除代价高



## SQL Sever的数据存储结构

SQL Server的数据库文件是多个对象的集合 ，包括多个表、索引等

### 页

基本的数据存储单位是页, 大小为8KB. 

### 扩展盘区

扩展盘区是一种基本单元，可将其中的空间分配给表和索引。一个扩展盘区是 8 个邻接的页（或 64 KB）。扩展盘区分为统一拓展盘区和混合拓展盘区

- 统一扩展盘区: 由单个对象所有, 扩展盘区中的所有八页只能由拥有该盘区的对象使用
- 混合扩展盘区: 最多可由8个对象共享

通常从混合扩展盘区中向新表或新索引分配页。当表或索引增长到 8 页时，就变成统一扩展盘区。

### SQL sever文件组织

有三种类型的文件:

- 主要数据文件: 数据库的起点，指向数据库中文件的其它部分。 每个数据库都有一个主要数据文件。主要数据文件的推荐文件扩展名是 .mdf。
- 次要数据文件: 次要数据文件包含除主要数据文件外的所有数据文件。有些数据库可能没有次要数据文件，而有些数据库则有多个次要数据文件。次要数据文件的推荐文件扩展名是 .ndf。
- 日志文件: 日志文件包含恢复数据库所需的所有日志信息。每个数据库必须至少有一个日志文件，但可以不止一个。日志文件的推荐文件扩展名是 .ldf。

**bulk-loading**:批量载入

数据文件的页按顺序编号, 首页为0; 每个文件有一个文件ID号.
因此在数据库中唯一标识一页需要使用**文件ID+页码**.

即一个页码下面有很多个文件ID

老师将了一些关于数据的读写性能相关的东西, 比如B+ tree和LSM tree等. 索引结构不同

#### 文件的起始结构

文件头->PFS页->GAM页->SGAM页

**PFS页**: 可用空间. 每一页用1B的位图来进行判断, 记录有以下几种情况: 空的, 1-50%已满, 51-80%已满, 81-95%已满, 96-100%已满. 这是为了节约空间, 提高性能.

**GAM页**: 全局分配映射表(GAM)页用来记录已分配的扩展盘区, GAM对所涵盖区间内的每个扩展盘区都有一位, 若为1则是扩展盘区可用; 若为0则是已分配.

**SGAM页**: 共享全局分配映射表(SGAM), 记录特定的盘区. 特定盘区: 用作混合盘区且至少有个未使用的页. 若为1则该扩展盘区就用作混合扩展盘区且有可用的页, 若为0则不用作混合扩展盘区或所有页正在被使用中 .

*若SGAM为1, 则说明有页可以插入, 但如何插入呢, 这个时候就要使用PFS了*

![图十](/figures/04-10.png)

#### 表的组织

索引分配映射表IAM: 记录了分配给对象的扩展盘区。

数据页之间唯一的逻辑连接是记录在IAM页内的连接. 服务器使用 IAM 页查找数据页集合内的页，进行表扫描或串行读。

![图十一](/figures/04-11.png)

当 需要插入新行而当前页没有可用空间时，SQL Server 使用 IAM 页查找分配给对象的扩展盘区 。对于每个扩展盘区，SQL Server 搜索 PFS 页 以查看是否有一页具有足够的空间容纳这一行。

### SQL Server记录结构

```SQL
Create Table Fixed {
	col1 int,
	col2 char(5),
	col3 char(3),
	col4 float
}
```

## 考虑

如何衡量数据组织方法的优劣

- 性能
- 灵活性
- 复杂程度
- 空间利用率